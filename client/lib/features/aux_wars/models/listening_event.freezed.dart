// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'listening_event.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

ListeningEvent _$ListeningEventFromJson(Map<String, dynamic> json) {
  return _ListeningEvent.fromJson(json);
}

/// @nodoc
mixin _$ListeningEvent {
  String get id => throw _privateConstructorUsedError;
  String get title => throw _privateConstructorUsedError;
  String get artist => throw _privateConstructorUsedError;
  String get albumCover => throw _privateConstructorUsedError;
  String get eventName => throw _privateConstructorUsedError;
  String get eventHost => throw _privateConstructorUsedError;
  int get listenerCount => throw _privateConstructorUsedError;
  List<UserAvatar> get participants => throw _privateConstructorUsedError;
  bool get isExclusive => throw _privateConstructorUsedError;
  bool get isLive => throw _privateConstructorUsedError;

  /// Serializes this ListeningEvent to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of ListeningEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $ListeningEventCopyWith<ListeningEvent> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ListeningEventCopyWith<$Res> {
  factory $ListeningEventCopyWith(
          ListeningEvent value, $Res Function(ListeningEvent) then) =
      _$ListeningEventCopyWithImpl<$Res, ListeningEvent>;
  @useResult
  $Res call(
      {String id,
      String title,
      String artist,
      String albumCover,
      String eventName,
      String eventHost,
      int listenerCount,
      List<UserAvatar> participants,
      bool isExclusive,
      bool isLive});
}

/// @nodoc
class _$ListeningEventCopyWithImpl<$Res, $Val extends ListeningEvent>
    implements $ListeningEventCopyWith<$Res> {
  _$ListeningEventCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of ListeningEvent
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? title = null,
    Object? artist = null,
    Object? albumCover = null,
    Object? eventName = null,
    Object? eventHost = null,
    Object? listenerCount = null,
    Object? participants = null,
    Object? isExclusive = null,
    Object? isLive = null,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      title: null == title
          ? _value.title
          : title // ignore: cast_nullable_to_non_nullable
              as String,
      artist: null == artist
          ? _value.artist
          : artist // ignore: cast_nullable_to_non_nullable
              as String,
      albumCover: null == albumCover
          ? _value.albumCover
          : albumCover // ignore: cast_nullable_to_non_nullable
              as String,
      eventName: null == eventName
          ? _value.eventName
          : eventName // ignore: cast_nullable_to_non_nullable
              as String,
      eventHost: null == eventHost
          ? _value.eventHost
          : eventHost // ignore: cast_nullable_to_non_nullable
              as String,
      listenerCount: null == listenerCount
          ? _value.listenerCount
          : listenerCount // ignore: cast_nullable_to_non_nullable
              as int,
      participants: null == participants
          ? _value.participants
          : participants // ignore: cast_nullable_to_non_nullable
              as List<UserAvatar>,
      isExclusive: null == isExclusive
          ? _value.isExclusive
          : isExclusive // ignore: cast_nullable_to_non_nullable
              as bool,
      isLive: null == isLive
          ? _value.isLive
          : isLive // ignore: cast_nullable_to_non_nullable
              as bool,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ListeningEventImplCopyWith<$Res>
    implements $ListeningEventCopyWith<$Res> {
  factory _$$ListeningEventImplCopyWith(_$ListeningEventImpl value,
          $Res Function(_$ListeningEventImpl) then) =
      __$$ListeningEventImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      String title,
      String artist,
      String albumCover,
      String eventName,
      String eventHost,
      int listenerCount,
      List<UserAvatar> participants,
      bool isExclusive,
      bool isLive});
}

/// @nodoc
class __$$ListeningEventImplCopyWithImpl<$Res>
    extends _$ListeningEventCopyWithImpl<$Res, _$ListeningEventImpl>
    implements _$$ListeningEventImplCopyWith<$Res> {
  __$$ListeningEventImplCopyWithImpl(
      _$ListeningEventImpl _value, $Res Function(_$ListeningEventImpl) _then)
      : super(_value, _then);

  /// Create a copy of ListeningEvent
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? title = null,
    Object? artist = null,
    Object? albumCover = null,
    Object? eventName = null,
    Object? eventHost = null,
    Object? listenerCount = null,
    Object? participants = null,
    Object? isExclusive = null,
    Object? isLive = null,
  }) {
    return _then(_$ListeningEventImpl(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      title: null == title
          ? _value.title
          : title // ignore: cast_nullable_to_non_nullable
              as String,
      artist: null == artist
          ? _value.artist
          : artist // ignore: cast_nullable_to_non_nullable
              as String,
      albumCover: null == albumCover
          ? _value.albumCover
          : albumCover // ignore: cast_nullable_to_non_nullable
              as String,
      eventName: null == eventName
          ? _value.eventName
          : eventName // ignore: cast_nullable_to_non_nullable
              as String,
      eventHost: null == eventHost
          ? _value.eventHost
          : eventHost // ignore: cast_nullable_to_non_nullable
              as String,
      listenerCount: null == listenerCount
          ? _value.listenerCount
          : listenerCount // ignore: cast_nullable_to_non_nullable
              as int,
      participants: null == participants
          ? _value._participants
          : participants // ignore: cast_nullable_to_non_nullable
              as List<UserAvatar>,
      isExclusive: null == isExclusive
          ? _value.isExclusive
          : isExclusive // ignore: cast_nullable_to_non_nullable
              as bool,
      isLive: null == isLive
          ? _value.isLive
          : isLive // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ListeningEventImpl implements _ListeningEvent {
  const _$ListeningEventImpl(
      {required this.id,
      required this.title,
      required this.artist,
      required this.albumCover,
      required this.eventName,
      required this.eventHost,
      required this.listenerCount,
      required final List<UserAvatar> participants,
      required this.isExclusive,
      required this.isLive})
      : _participants = participants;

  factory _$ListeningEventImpl.fromJson(Map<String, dynamic> json) =>
      _$$ListeningEventImplFromJson(json);

  @override
  final String id;
  @override
  final String title;
  @override
  final String artist;
  @override
  final String albumCover;
  @override
  final String eventName;
  @override
  final String eventHost;
  @override
  final int listenerCount;
  final List<UserAvatar> _participants;
  @override
  List<UserAvatar> get participants {
    if (_participants is EqualUnmodifiableListView) return _participants;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_participants);
  }

  @override
  final bool isExclusive;
  @override
  final bool isLive;

  @override
  String toString() {
    return 'ListeningEvent(id: $id, title: $title, artist: $artist, albumCover: $albumCover, eventName: $eventName, eventHost: $eventHost, listenerCount: $listenerCount, participants: $participants, isExclusive: $isExclusive, isLive: $isLive)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ListeningEventImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.title, title) || other.title == title) &&
            (identical(other.artist, artist) || other.artist == artist) &&
            (identical(other.albumCover, albumCover) ||
                other.albumCover == albumCover) &&
            (identical(other.eventName, eventName) ||
                other.eventName == eventName) &&
            (identical(other.eventHost, eventHost) ||
                other.eventHost == eventHost) &&
            (identical(other.listenerCount, listenerCount) ||
                other.listenerCount == listenerCount) &&
            const DeepCollectionEquality()
                .equals(other._participants, _participants) &&
            (identical(other.isExclusive, isExclusive) ||
                other.isExclusive == isExclusive) &&
            (identical(other.isLive, isLive) || other.isLive == isLive));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      title,
      artist,
      albumCover,
      eventName,
      eventHost,
      listenerCount,
      const DeepCollectionEquality().hash(_participants),
      isExclusive,
      isLive);

  /// Create a copy of ListeningEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$ListeningEventImplCopyWith<_$ListeningEventImpl> get copyWith =>
      __$$ListeningEventImplCopyWithImpl<_$ListeningEventImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ListeningEventImplToJson(
      this,
    );
  }
}

abstract class _ListeningEvent implements ListeningEvent {
  const factory _ListeningEvent(
      {required final String id,
      required final String title,
      required final String artist,
      required final String albumCover,
      required final String eventName,
      required final String eventHost,
      required final int listenerCount,
      required final List<UserAvatar> participants,
      required final bool isExclusive,
      required final bool isLive}) = _$ListeningEventImpl;

  factory _ListeningEvent.fromJson(Map<String, dynamic> json) =
      _$ListeningEventImpl.fromJson;

  @override
  String get id;
  @override
  String get title;
  @override
  String get artist;
  @override
  String get albumCover;
  @override
  String get eventName;
  @override
  String get eventHost;
  @override
  int get listenerCount;
  @override
  List<UserAvatar> get participants;
  @override
  bool get isExclusive;
  @override
  bool get isLive;

  /// Create a copy of ListeningEvent
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$ListeningEventImplCopyWith<_$ListeningEventImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

UserAvatar _$UserAvatarFromJson(Map<String, dynamic> json) {
  return _UserAvatar.fromJson(json);
}

/// @nodoc
mixin _$UserAvatar {
  String get id => throw _privateConstructorUsedError;
  String get name => throw _privateConstructorUsedError;
  String get avatarUrl => throw _privateConstructorUsedError;
  double get x =>
      throw _privateConstructorUsedError; // Position as percentage of screen width
  double get y =>
      throw _privateConstructorUsedError; // Position as percentage of screen height
  String? get message => throw _privateConstructorUsedError;
  bool? get isActive => throw _privateConstructorUsedError;
  bool? get isWaving => throw _privateConstructorUsedError;
  bool? get showHeart => throw _privateConstructorUsedError;

  /// Serializes this UserAvatar to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of UserAvatar
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $UserAvatarCopyWith<UserAvatar> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $UserAvatarCopyWith<$Res> {
  factory $UserAvatarCopyWith(
          UserAvatar value, $Res Function(UserAvatar) then) =
      _$UserAvatarCopyWithImpl<$Res, UserAvatar>;
  @useResult
  $Res call(
      {String id,
      String name,
      String avatarUrl,
      double x,
      double y,
      String? message,
      bool? isActive,
      bool? isWaving,
      bool? showHeart});
}

/// @nodoc
class _$UserAvatarCopyWithImpl<$Res, $Val extends UserAvatar>
    implements $UserAvatarCopyWith<$Res> {
  _$UserAvatarCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of UserAvatar
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
    Object? avatarUrl = null,
    Object? x = null,
    Object? y = null,
    Object? message = freezed,
    Object? isActive = freezed,
    Object? isWaving = freezed,
    Object? showHeart = freezed,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      avatarUrl: null == avatarUrl
          ? _value.avatarUrl
          : avatarUrl // ignore: cast_nullable_to_non_nullable
              as String,
      x: null == x
          ? _value.x
          : x // ignore: cast_nullable_to_non_nullable
              as double,
      y: null == y
          ? _value.y
          : y // ignore: cast_nullable_to_non_nullable
              as double,
      message: freezed == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String?,
      isActive: freezed == isActive
          ? _value.isActive
          : isActive // ignore: cast_nullable_to_non_nullable
              as bool?,
      isWaving: freezed == isWaving
          ? _value.isWaving
          : isWaving // ignore: cast_nullable_to_non_nullable
              as bool?,
      showHeart: freezed == showHeart
          ? _value.showHeart
          : showHeart // ignore: cast_nullable_to_non_nullable
              as bool?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$UserAvatarImplCopyWith<$Res>
    implements $UserAvatarCopyWith<$Res> {
  factory _$$UserAvatarImplCopyWith(
          _$UserAvatarImpl value, $Res Function(_$UserAvatarImpl) then) =
      __$$UserAvatarImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      String name,
      String avatarUrl,
      double x,
      double y,
      String? message,
      bool? isActive,
      bool? isWaving,
      bool? showHeart});
}

/// @nodoc
class __$$UserAvatarImplCopyWithImpl<$Res>
    extends _$UserAvatarCopyWithImpl<$Res, _$UserAvatarImpl>
    implements _$$UserAvatarImplCopyWith<$Res> {
  __$$UserAvatarImplCopyWithImpl(
      _$UserAvatarImpl _value, $Res Function(_$UserAvatarImpl) _then)
      : super(_value, _then);

  /// Create a copy of UserAvatar
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
    Object? avatarUrl = null,
    Object? x = null,
    Object? y = null,
    Object? message = freezed,
    Object? isActive = freezed,
    Object? isWaving = freezed,
    Object? showHeart = freezed,
  }) {
    return _then(_$UserAvatarImpl(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      avatarUrl: null == avatarUrl
          ? _value.avatarUrl
          : avatarUrl // ignore: cast_nullable_to_non_nullable
              as String,
      x: null == x
          ? _value.x
          : x // ignore: cast_nullable_to_non_nullable
              as double,
      y: null == y
          ? _value.y
          : y // ignore: cast_nullable_to_non_nullable
              as double,
      message: freezed == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String?,
      isActive: freezed == isActive
          ? _value.isActive
          : isActive // ignore: cast_nullable_to_non_nullable
              as bool?,
      isWaving: freezed == isWaving
          ? _value.isWaving
          : isWaving // ignore: cast_nullable_to_non_nullable
              as bool?,
      showHeart: freezed == showHeart
          ? _value.showHeart
          : showHeart // ignore: cast_nullable_to_non_nullable
              as bool?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$UserAvatarImpl implements _UserAvatar {
  const _$UserAvatarImpl(
      {required this.id,
      required this.name,
      required this.avatarUrl,
      required this.x,
      required this.y,
      this.message,
      this.isActive,
      this.isWaving,
      this.showHeart});

  factory _$UserAvatarImpl.fromJson(Map<String, dynamic> json) =>
      _$$UserAvatarImplFromJson(json);

  @override
  final String id;
  @override
  final String name;
  @override
  final String avatarUrl;
  @override
  final double x;
// Position as percentage of screen width
  @override
  final double y;
// Position as percentage of screen height
  @override
  final String? message;
  @override
  final bool? isActive;
  @override
  final bool? isWaving;
  @override
  final bool? showHeart;

  @override
  String toString() {
    return 'UserAvatar(id: $id, name: $name, avatarUrl: $avatarUrl, x: $x, y: $y, message: $message, isActive: $isActive, isWaving: $isWaving, showHeart: $showHeart)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UserAvatarImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.avatarUrl, avatarUrl) ||
                other.avatarUrl == avatarUrl) &&
            (identical(other.x, x) || other.x == x) &&
            (identical(other.y, y) || other.y == y) &&
            (identical(other.message, message) || other.message == message) &&
            (identical(other.isActive, isActive) ||
                other.isActive == isActive) &&
            (identical(other.isWaving, isWaving) ||
                other.isWaving == isWaving) &&
            (identical(other.showHeart, showHeart) ||
                other.showHeart == showHeart));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, id, name, avatarUrl, x, y,
      message, isActive, isWaving, showHeart);

  /// Create a copy of UserAvatar
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$UserAvatarImplCopyWith<_$UserAvatarImpl> get copyWith =>
      __$$UserAvatarImplCopyWithImpl<_$UserAvatarImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$UserAvatarImplToJson(
      this,
    );
  }
}

abstract class _UserAvatar implements UserAvatar {
  const factory _UserAvatar(
      {required final String id,
      required final String name,
      required final String avatarUrl,
      required final double x,
      required final double y,
      final String? message,
      final bool? isActive,
      final bool? isWaving,
      final bool? showHeart}) = _$UserAvatarImpl;

  factory _UserAvatar.fromJson(Map<String, dynamic> json) =
      _$UserAvatarImpl.fromJson;

  @override
  String get id;
  @override
  String get name;
  @override
  String get avatarUrl;
  @override
  double get x; // Position as percentage of screen width
  @override
  double get y; // Position as percentage of screen height
  @override
  String? get message;
  @override
  bool? get isActive;
  @override
  bool? get isWaving;
  @override
  bool? get showHeart;

  /// Create a copy of UserAvatar
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$UserAvatarImplCopyWith<_$UserAvatarImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
